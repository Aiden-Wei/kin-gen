/********************************************************** 
   This file was generated automatically: DO NOT MODIFY

    This source file is part of the user-code that
    implements a Taste function block component generated
    with the ESROCOS robot modeling tool.

  
  Delivered by: KU Leuven, Belgium, 2018
  Generated on: Fri Apr  6 15:44:44 2018 (UTC)
  Generated by: 
  License:      BSD 2-clause

**********************************************************/

#include <kingen/ur5/ur5.h>
#include "static_conversions.h"
#include "kinblock-bridge.h"

ur5::mc_config mc;

void load_model_constants() {
    // initialize model constants
}

void joint_state_conversion(const asn1SccBase_JointState *asn, ur5::joint_state &q) {
    for(unsigned int i=0; i<ur5::dofs_count; i++) {
        q(i) = asn[i].position;
    }
}


void joint_state_conversion(const ur5::joint_state &q, asn1SccBase_JointState *asn) {
    for(unsigned int i=0; i<ur5::dofs_count; i++) {
        asn[i].position = q(i);
    }
}


int solver_fk1(const asn1SccBase_JointState *IN_joints, asn1SccBase_Pose *outval_1) {
  ur5::joint_state input; kul::pose_t output_1; ur5::Jacobian_t output_2; ur5::Jacobian_t output_3;
  joint_state_conversion(IN_joints,input);
  ur5::fk1(mc,input,output_1,output_2,output_3);
  internal::Quaternion __or;
rot2quat(kul::eg_get_rotation(output_1),__or);

(outval_1->orientation).im.arr[0] = __or.data[1];
(outval_1->orientation).im.arr[1] = __or.data[2];
(outval_1->orientation).im.arr[2] = __or.data[3];
(outval_1->orientation).re = __or.data[0];
outval_1->position.data.arr[0] = kul::eg_get_position(output_1)(0,0);
outval_1->position.data.arr[1] = kul::eg_get_position(output_1)(1,0);
outval_1->position.data.arr[2] = kul::eg_get_position(output_1)(2,0);

  return 0;
}


int solver_fk2(const asn1SccBase_JointState *IN_joints, asn1SccBase_Pose *outval_1) {
  ur5::joint_state input; kul::pose_t output_1;
  joint_state_conversion(IN_joints,input);
  ur5::fk2(mc,input,output_1);
  internal::Quaternion __or;
rot2quat(kul::eg_get_rotation(output_1),__or);

(outval_1->orientation).im.arr[0] = __or.data[1];
(outval_1->orientation).im.arr[1] = __or.data[2];
(outval_1->orientation).im.arr[2] = __or.data[3];
(outval_1->orientation).re = __or.data[0];
outval_1->position.data.arr[0] = kul::eg_get_position(output_1)(0,0);
outval_1->position.data.arr[1] = kul::eg_get_position(output_1)(1,0);
outval_1->position.data.arr[2] = kul::eg_get_position(output_1)(2,0);

  return 0;
}


int solver_ik1(const asn1SccBase_JointState *IN_q, const asn1SccWrappers_Vector3d *IN_vector, asn1SccBase_JointState *OUT_qd_ik) {
  ur5::joint_state q; kul::vector3_t vector; ur5::joint_state qd_ik;
  joint_state_conversion(IN_q,q);
  ur5::ik1(mc,q, vector, qd_ik);
  joint_state_conversion(qd_ik,OUT_qd_ik);
  return 0;
}


int solver_ik2(const asn1SccWrappers_Vector3d *IN_position, const asn1SccWrappers_Quaterniond*IN_orientation, asn1SccBase_JointState*IN_guess, asn1SccBase_JointState *OUT_q_ik) {
  kul::ik_pos_cfg cfg; kul::vector3_t desired_position; kul::rot_m_t desired_orientation; ur5::joint_state q_guess; ur5::joint_state q_ik; kul::ik_pos_dbg dbg;
  desired_position(0,0) = IN_position->data.arr[0];
  desired_position(1,0) = IN_position->data.arr[1];
  desired_position(2,0) = IN_position->data.arr[2];
internal::Quaternion __or;
__or.data[1] = (*IN_orientation).im.arr[0];
__or.data[2] = (*IN_orientation).im.arr[1];
__or.data[3] = (*IN_orientation).im.arr[2];
__or.data[0] = (*IN_orientation).re;

quat2rot(__or,desired_orientation);

  ur5::ik2(mc,cfg, desired_position, desired_orientation, q_guess, q_ik, dbg);
  joint_state_conversion(q_ik,OUT_q_ik);
  return 0;
}
